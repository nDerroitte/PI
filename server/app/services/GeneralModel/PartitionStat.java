package services;

import org.apache.commons.math3.linear.ArrayRealVector;
import org.apache.commons.math3.ml.clustering.DBSCANClusterer;
import org.apache.commons.math3.ml.clustering.DoublePoint;

import services.ComputeHabit;

import org.apache.commons.math3.ml.clustering.Cluster;
import org.apache.commons.math3.distribution.NormalDistribution;

import java.util.List;
import java.util.Iterator;
/**
 * Make stat on partition generated by {@link services.ComputeHabit#cluster cluster}
 * Use in {@link services.ComputeHabit#partitionScore partitionScore}
 * 
 * A partition is a list of cluster. Each cluster contains the date when an habit occur.
 * 
 */
class PartitionStat {
    /**
     * Partition on which stat are made
     */
    List<Cluster<DoublePoint>> partition; 
    /**
     * Circular mean of each cluster of the partition
     */
    private double[] mean; 
    /**
     * Circular standard deviation of each cluster of the partition
     */
    private double[] std; 
    /**
     * Number of point in a cluster over what is expected.
     */
    private double[] reliability; 
    /**
     * Proportion of point explained by the partition.
     *  */ 
    private double noise;
    /**
     * Parameter of the circular space on which the cluster are made.
     * The circular space domain are the integer in [0,period], each integer r
     * are map to r % period.
     */
    private double period; 
    /**
     * The total number of point in all cluster.
     */
    private int point_in_clusters; 
    /**
     * The expected number of point in a cluster.
     */
    private int realisation; 
    /**
     * The total number of point from which the clustering is performed.
     */
    private int total_point; 

    /**
     * 
     * @param p The partition
     * @param r The expected number of point in a cluster.
     * @param period The parameter of the circular space on which the clustering is performed.
     * The circular space domain are the integer in [0,period], each integer r
     * are map to r % period.
     * @param total_point the total number of point from which the clustering is performed.
     */
    public PartitionStat(List<Cluster<DoublePoint>> p, int r, double period, int total_point) {
        partition = p;
        realisation = r;
        mean = new double[partition.size()];
        std = new double[partition.size()];
        reliability = new double[partition.size()];
        this.period = period;
        this.total_point = total_point;
        compute();
    }
/**
 * Return the circular mean of each cluster
 * 
 * @return The circular mean of each cluster
 */
    double[] getMeans() {
        return mean;
    }
/**
 * Return the circular standard deviation of each cluster.
 * 
 * @return The circular standard deviation of each cluster.
 */
    double[] getStd() {
        return std;
    }
/**
 * Return the number of point in a cluster over what is expected for each cluster.
 * 
 * @return The number of point in a cluster over what is expected.
 *   If there is more point in a cluster than expected, return 1 for this cluster.
 */
    double[] getReliability() {
        return reliability;
    }
/**
 * Return the proportion of point unexpected not in a cluster or out of a cluster.
 * 
 * @return Use the formula: (total_point - point_explained) / total_point.
 * total_point is the number of point from which the clustering is performed.
 * point_explained is the total number of point in a cluster which are expected.
 */
    double getNoise() {
        return noise;
    }

    public String toString() {
        return "period:" + period + " noise: " + noise + " total_point: " + total_point + " point in cluster: "
                + point_in_clusters + " realisation " + realisation + "\n average reliability: "
                + Stat.mean(reliability) + " average std: " + Stat.mean(std);
    }
/**
 * Compute the stat. 
 */
    void compute() {
        Iterator<Cluster<DoublePoint>> ite = partition.iterator();
        if (!ite.hasNext()) {
            return;
        }
        int point_explained = 0;
        for (int i = 0; ite.hasNext(); i++) {
            Cluster<DoublePoint> c = ite.next();
            double[] tmp = Stat.clusterStat(c, (int) period);
            mean[i] = tmp[0];
            std[i] = tmp[1];
            reliability[i] = Math.max(1,(double) c.getPoints().size() / (double) realisation);
            point_explained += Math.min(c.getPoints().size(), realisation);
        }
        this.noise = (total_point - point_explained) / (double) total_point;
        return;
    }
}